<?php

/**
 * @file
 * Primary hooks for rss_external_entities module.
 */

use Acquia\Blt\Robo\Common\EnvironmentDetector;
use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\rss_external_entities\Plugin\ExternalEntities\StorageClient\ExternalRssInterface;

/**
 * Implements hook_preprocess_block().
 */
function rss_external_entities_preprocess_block(&$variables) {
  if ($variables['plugin_id'] === 'external_rss' && isset($variables['content']['#attributes'])) {
    $variables['attributes'] = NestedArray::mergeDeep($variables['attributes'] ?? [], $variables['content']['#attributes']);
  }
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function rss_external_entities_theme_suggestions_block_alter(array &$suggestions, array $variables) {
  if ($variables['elements']['#plugin_id'] === 'external_rss') {
    $suggestions[] = 'block__external_rss__' . $variables['elements']['#configuration']['storage'];
  }
  return $suggestions;
}

/**
 * Implements hook_cron().
 */
function rss_external_entities_cron() {
  $rss_manager = \Drupal::service('rss_external_entities.rss_manager');
  $timer = \Drupal::service('datetime.time');

  $logger = $rss_manager->getLogger();
  $rss_storage_clients = $rss_manager->getAllRssStorageClient();

  foreach ($rss_storage_clients as $rss_storage_client) {
    /** @var \Drupal\rss_external_entities\Plugin\ExternalEntities\StorageClient\ExternalRssInterface $rss_storage_client */

    // Skip if no cron.
    if (!$rss_storage_client->isCronRestore()) {
      continue;
    }

    $interval = $rss_storage_client->getCronRestoreInterval();
    $last_cron_restore = $rss_storage_client->getLastCronRestoreTime();
    $request_time = $timer->getRequestTime();

    // Skip if not time yet.
    if ($last_cron_restore + $interval > $request_time) {
      continue;
    }

    try {
      $xml = $rss_storage_client->getXml();

      if (empty($xml)) {
        throw new Exception('The xml content was empty', 204);
      }
    }
    catch (\Throwable $e) {
      $rss_storage_client->sendEmail(NULL, $e);
      $logger->error(t('<p>Failed to restore the %label rss (code: @code):<br />@message.</p>', [
        '%label' => $rss_storage_client->getExternalEntityType()->label(),
        '@code' => $e->getCode(),
        '@message' => $e->getMessage(),
      ]));
      continue;
    }

    // Restore xml, and cache invalidate.
    $rss_storage_client->setStoredXml($xml);
    Cache::invalidateTags($rss_storage_client->getCacheTagsToInvalidate());

    $logger->info(t('<p>Restore the %name rss successfully.</p>', [
      '%name' => $rss_storage_client->getExternalEntityType()->label(),
    ]));
  }
}

/**
 * Implements hook_mail().
 */
function rss_external_entities_mail($key, &$message, $params) {
  if ($key !== ExternalRssInterface::MAIL_KEY) {
    return;
  }
  $message['external_entity_type'] = $params['external_entity_type'];
  $message['subject'] = $params['subject'];
  $message['body'][] = $params['body'];
}

/**
 * Implements hook_mail_alter().
 */
function rss_external_entities_mail_alter(&$message) {
  if ($message['key'] === ExternalRssInterface::MAIL_KEY) {
    $message['send'] = TRUE;
    // Implements hook_external_rss_notify_mail_alter().
    \Drupal::moduleHandler()->alter(ExternalRssInterface::MAIL_KEY . '_mail', $message);
    unset($message['external_entity_type']);
  }
}

/**
 * Implements hook_token_info_alter().
 */
function rss_external_entities_token_info_alter(&$data) {
  $token_type = ExternalRssInterface::TOKEN_TYPE;

  // Token types.
  $data['types'][$token_type] = [
    'name' => t('External Rss'),
    'description' => t('Tokens related to external rss.'),
  ];

  $data['types']["$token_type-name"] = [
    'name' => t('External Rss name'),
    'description' => t('Tokens related to external rss name.'),
    'needs-data' => "$token_type-name",
  ];

  $data['types']["$token_type-env"] = [
    'name' => t('External Rss environment'),
    'description' => t('Tokens related to external rss environment.'),
    'needs-data' => "$token_type-env",
  ];

  $data['types']["$token_type-endpoint"] = [
    'name' => t('External Rss endpoint'),
    'description' => t('Tokens related to external rss endpoint.'),
    'needs-data' => "$token_type-endpoint",
  ];

  $data['types']["$token_type-error"] = [
    'name' => t('External Rss error'),
    'description' => t('Tokens related to external rss error.'),
    'needs-data' => "$token_type-error",
  ];

  $data['types']["$token_type-error-code"] = [
    'name' => t('External Rss error code'),
    'description' => t('Tokens related to external rss error code.'),
    'needs-data' => "$token_type-error-code",
  ];

  $data['types']["$token_type-error-message"] = [
    'name' => t('External Rss error message'),
    'description' => t('Tokens related to external rss error message.'),
    'needs-data' => "$token_type-error-message",
  ];

  // Token placeholder.
  // [external_rss:name]
  $data['tokens'][$token_type]['name'] = [
    'name' => t('External Rss name'),
    'description' => t('Name of external rss'),
    'type' => "$token_type-name",
  ];

  // [external_rss:env]
  $data['tokens'][$token_type]['env'] = [
    'name' => t('External Rss environment'),
    'description' => t('Environment of external rss'),
    'type' => "$token_type-env",
  ];

  // [external_rss:endpoint]
  $data['tokens'][$token_type]['endpoint'] = [
    'name' => t('External Rss endpoint'),
    'description' => t('Endpoint of external rss'),
    'type' => "$token_type-endpoint",
  ];

  // [external_rss:error]
  $data['tokens'][$token_type]['error'] = [
    'name' => t('External Rss error'),
    'description' => t('Request error of external rss.'),
    'type' => "$token_type-error",
  ];

  // [external_rss:error:code]
  $data['tokens']["$token_type-error"]['code'] = [
    'name' => t('External Rss error code'),
    'description' => t('Request error code of external rss.'),
    'type' => "$token_type-error-code",
  ];

  // [external_rss:error:message]
  $data['tokens']["$token_type-error"]['message'] = [
    'name' => t('External Rss error message'),
    'description' => t('Request error message of external rss.'),
    'type' => "$token_type-error-message",
  ];
}

/**
 * Implements hook_tokens().
 */
function rss_external_entities_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  $storage_client = $data['storage_client'] ?? NULL;
  $error = $data['error'] ?? new \Exception('Unknown error', 500);

  if ($type !== ExternalRssInterface::TOKEN_TYPE || !($storage_client instanceof ExternalRssInterface)) {
    return $replacements;
  }

  if (isset($tokens['name'])) {
    $replacements[$tokens['name']] = $storage_client->getExternalEntityType()->label();
  }

  if (isset($tokens['env'])) {
    $replacements[$tokens['env']] = class_exists(EnvironmentDetector::class) ? EnvironmentDetector::getAhEnv() : 'prod';
  }

  if (isset($tokens['endpoint'])) {
    $replacements[$tokens['endpoint']] = $storage_client->getEndpoint();
  }

  if (isset($tokens['error:code'])) {
    $replacements[$tokens['error:code']] = $error->getCode();
  }

  if (isset($tokens['error:message'])) {
    $replacements[$tokens['error:message']] = $error->getMessage();
  }

  $bubbleable_metadata->addCacheableDependency($storage_client);

  return $replacements;
}
